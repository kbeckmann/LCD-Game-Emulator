/*

This program permits to load ROM generated by LCD-Game-Shrinker.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.
This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

__author__ = "bzhxx"
__contact__ = "https://github.com/bzhxx"
__license__ = "GPLv3"

*/

//to be removed using arguments get rom pointer and size
#include "rom_manager.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#define GW_ROM_LZ4_SUPPORT 

#ifdef GW_ROM_LZ4_SUPPORT
#include "lz4_depack.h"
#endif

#include "gw_type_defs.h"
#include "gw_romloader.h"

//ROM in RAM
// size is 2 or 4 images in 16bits format (1 screen or 2screen swapping)
// + 8kB rom+program
// + 8kB metadata
// = 4x320x240*2 + 2 x 4096
// = 622592 kB

unsigned char GW_ROM[622592] __attribute__((aligned (4)));

unsigned short *gw_background=NULL;
unsigned char  *gw_segments=NULL;
unsigned short *gw_segments_x=NULL;
unsigned short *gw_segments_y=NULL;
unsigned short *gw_segments_width=NULL;
unsigned short *gw_segments_height=NULL;
unsigned int   *gw_segments_offset=NULL;
unsigned char  *gw_program=NULL;
unsigned char  *gw_melody=NULL;
unsigned int   *gw_keyboard=NULL;

gwromheader_t gw_head;

/**************** Background *******************/
/*
	Background extracted and adapted to GW LCD from BackgroundNS.png file
	RGB565 16bits pixel format 
*/
// unsigned short gw_background_data[320*240];

/**************** segments *******************/
/* 
segments extracted and adapted to GW LCD from .svg file 
RGB565 16bits pixel format 
the data segments are smaller than the reserved memory 
*/ 

//unsigned short gw_segments_data[320*240];
// unsigned short gw_segments_x[NB_SEGS];
// unsigned short gw_segments_y[NB_SEGS];
// unsigned short gw_segments_width[NB_SEGS];
// unsigned short gw_segments_height[NB_SEGS];
// unsigned int   gw_segments_offset[NB_SEGS];

/**************** program file *******************/
// unsigned char gw_program[4096];

/**************** melody file *******************/
// unsigned char gw_melody[4096];

/*** G&W Buttons to CPU inputs Mapping ***/
/* 
S1..S8 x K1..4 keyboard matrix input on SM5xx emulated CPU
BA,B direct input on SM5xx emulated CPU
8 buttons on G&W SM

Buttons to keyboards mapping MSB..LSB defined on 8 bits
LEFT | RIGHT | UP | DOWN |A | GAME | SELECT


keyboard[0] is S1 K4..K1
keyboard[1] is S2 K4..K1
.
keyboard[7] is S2 K4..K1
keyboard[8] is BA (8 bits lsb)
keyboard[9] is B   (8 bits lsb)
*/
// unsigned int gw_keyboard[10];

bool gw_romloader_rom2ram()
{

   /* src pointer to the ROM data in the external flash (raw or LZ4) */
   const unsigned char *src = (unsigned char *) ROM_DATA;

   /* dest pointer to the ROM data in the internal RAM (raw) */
   unsigned char       *dest = (unsigned char *) GW_ROM;

   /* variable used to compare the size to detect error  */
   unsigned int rom_size_src,rom_size_dest;

   /* cleanup destination memory with white color (in case of no background) */
   memset(dest, 0xffff, sizeof(GW_ROM));

   /* Check it by testing 3 first characters == SM5 */
   if ( memcmp(src, ROM_CPU_SM510, 3) == 0 ) {
      printf("Not compressed : header OK\n");

      memcpy(dest,src,ROM_DATA_LENGTH);
      printf("ROM2RAM done\n");

      rom_size_src = ROM_DATA_LENGTH;

#ifdef GW_ROM_LZ4_SUPPORT

   /* Check if it's compressed */
   } else if ( memcmp(src, LZ4_MAGIC, 4) == 0  ) {
      printf("ROM LZ4 detected\n");

      rom_size_src = lz4_uncompress(src, dest);
         
      if ((memcmp(dest, ROM_CPU_SM510, 3) == 0)) {
         printf("ROM LZ4 : header OK\n");
#endif

      } else {

         printf("ROM LZ4 : header KO\n");
         return false;
      }

   /* Something wrong in the ROM detection... */
   } else {
      printf("Unknow ROM format\n");
      return false;
   }

   /* Read in the ROM header */
	memcpy(&gw_head, dest, sizeof(gw_head));

   /* check size */
   /*Check if the data size matches. based on the last object in the ROM header (keyboard) */
   rom_size_dest = le_to_native_32(gw_head.keyboard) + le_to_native_32(gw_head.keyboard_size);

   if (rom_size_src != rom_size_dest )   {
            printf("CPU_name=%s\n", gw_head.cpu_name);
            printf("signature%s\n", gw_head.rom_signature);
            printf("ROM ERROR,size=%u,expected=%u\n",rom_size_src , rom_size_dest);
            return false;
   } else {
            printf("ROM size: OK\n");
   }

   /* Manage the background */

   // check if there is a uncompressed background inside
   if ( le_to_native_32(gw_head.background_pixel_size) != 0)
      gw_background    = (unsigned short*) &GW_ROM[le_to_native_32(gw_head.background_pixel)];
   
   // otherwise we set the background at the end (assuming futur JPEG decoder)
   else
      gw_background    = (unsigned short*) &GW_ROM[rom_size_src];

   //TODO JPEG decoder
   // check if there is a compressed background file after the LZ4 decompressed ROM
  // if (rom_size_src < ) {

  // }

   /* Set up pointers to objects base */
   gw_segments         = (unsigned char*)  &GW_ROM[le_to_native_32(gw_head.segments_pixel)];

   gw_segments_x       = (unsigned short*) &GW_ROM[le_to_native_32(gw_head.segments_x)];
   gw_segments_y       = (unsigned short*) &GW_ROM[le_to_native_32(gw_head.segments_y)];
   gw_segments_width   = (unsigned short*) &GW_ROM[le_to_native_32(gw_head.segments_width)];
   gw_segments_height  = (unsigned short*) &GW_ROM[le_to_native_32(gw_head.segments_height)];
   gw_segments_offset  = (unsigned int*)   &GW_ROM[le_to_native_32(gw_head.segments_offset)];

   gw_program          = (unsigned char*)  &GW_ROM[le_to_native_32(gw_head.program)];

   if ( le_to_native_32(gw_head.melody_size) != 0)
      gw_melody        = (unsigned char*)  &GW_ROM[le_to_native_32(gw_head.melody)];

   gw_keyboard         = (unsigned int*)   &GW_ROM[le_to_native_32(gw_head.keyboard)];

   return true;
}

/* Load a ROM image into memory */
bool gw_romloader()
{
   printf("gw_romloader\n");

   bool rom_status = gw_romloader_rom2ram();
   
   //debug
   if (!rom_status) assert(false);
  
   return rom_status;
}